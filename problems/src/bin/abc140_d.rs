use proconio::{input, marker::Chars};

/**
 * https://atcoder.jp/contests/abc140/tasks/abc140_d
 * https://drken1215.hatenablog.com/entry/2020/05/16/005300
 *
 * とてもメタ思考的なことを言うと、「操作を最大K回まで行うことができる」という問題設定は、アルゴリズム的にできることがとても限られてくる。
 * - 1 回操作するごとに、何らかの値が規則的に変化していく
 * - なんらかの意味で Greedy に、順にやっていくとよい
 *
 * そしてそういう解法にもっていくためには、とにかく「操作の意味をわかりやすく言い換える」というのが大変重要になってくる。
 *
 * => N−1箇所ある「隙間」のうち、'L' と 'R' の変わり目の個数を除いた値ということになる。
 * => N - 1 - a
 *
 * 一回の操作で「'L' と 'R' の変わり目」を最大で 2 箇所ずつ消すことができる
 * ただし、最大はN-1（全て同じ向きでも、目の前に人が居ない場合、幸福ではないため）
 * => N−1−max(a−2K,0)
 */
fn main() {
    input! {
        n: usize,
        k: usize,
        s: Chars,
    }

    let mut a = 0;
    for i in 1..n {
        if s[i - 1] != s[i] {
            a += 1;
        }
    }

    println!(
        "{}",
        if a > 2 * k {
            n - 1 - (a - 2 * k)
        } else {
            n - 1
        }
    );
}
